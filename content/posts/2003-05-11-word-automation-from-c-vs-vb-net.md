I recently received a question about doing some Word automation using .NET, and I saw an interesting little difference between the C# and VB.NET calling into the Interop Assembly for certain properties/methods&#8230;

If I take VBA or VB6 code that works, and convert it to the almost identical VB.NET code &#8230; (after adding a reference to Word in my VB.NET project);

<font color="#000000"></font><font face="Courier New"><font color="#0000ff">Dim </font><font color="#000000">wordApp </font><font color="#0000ff">As New </font><font color="#000000">Word.Application() </font><br /><font color="#0000ff">Dim </font><font color="#000000">newDoc </font><font color="#0000ff">As </font></font><font face="Courier New"><font color="#000000">Word.Document = wordApp.Documents.Add <br />newDoc.Range.Text = &#8220;Test&#8221; <br />newDoc.AttachedTemplate = &#8220;C:\&#8230;.\Macmillan.dot&#8221; <br />wordApp.Visible = </font><font color="#0000ff">True</font></font>

<font color="#0000ff"></font>  
It works fine, but in C# I get an error setting the AttachedTemplate property;

error CS1545: Property, indexer, or event &#8216;AttachedTemplate&#8217; is not supported by the language; try directly calling accessor methods &#8216;Word.\_Document.get\_AttachedTemplate()&#8217; or &#8216;Word.\_Document.set\_AttachedTemplate(ref object)&#8217; 

<font color="#000000"></font><font face="Courier New" color="#0000ff">object </font><font face="Courier New"><font color="#000000">missing = System.Reflection.Missing.Value;<br />Word.ApplicationClass wordApp = </font><font color="#0000ff">new </font></font><font face="Courier New"><font color="#000000">Word.ApplicationClass(); <br />Word.Document newDoc = wordApp.Documents.Add(</font><font color="#0000ff">ref </font><font color="#000000">missing, </font><font color="#0000ff">ref </font><font color="#000000">missing, </font><font color="#0000ff">ref </font><font color="#000000">missing, </font><font color="#0000ff">ref </font></font><font face="Courier New"><font color="#000000">missing); <br />newDoc.Range(</font><font color="#0000ff">ref </font><font color="#000000">missing,</font><font color="#0000ff">ref </font></font><font face="Courier New"><font color="#000000">missing).Text = &#8220;Test&#8221;; <br />newDoc.AttachedTemplate =&nbsp; @&#8221;C:\&#8230;.\Macmillan.dot&#8221;; <br />wordApp.Visible = </font><font color="#0000ff">true</font><font color="#000000">; </font><br /></font>  
I was able to make it work by writing the code like this;

<font color="#000000"></font><font face="Courier New" color="#0000ff">object </font><font face="Courier New"><font color="#000000">missing = System.Reflection.Missing.Value; <br />Word.ApplicationClass wordApp = </font><font color="#0000ff">new </font></font><font face="Courier New"><font color="#000000">Word.ApplicationClass(); <br />Word.Document newDoc = wordApp.Documents.Add(</font><font color="#0000ff">ref </font><font color="#000000">missing, </font><font color="#0000ff">ref </font><font color="#000000">missing, </font><font color="#0000ff">ref </font><font color="#000000">missing, </font><font color="#0000ff">ref </font><font color="#000000">missing); newDoc.Range(</font><font color="#0000ff">ref </font><font color="#000000">missing,</font><font color="#0000ff">ref </font><font color="#000000">missing).Text = &#8220;Test&#8221;; </font><br /><font color="#0000ff">object </font><font color="#000000">templateName = (</font><font color="#0000ff">object</font></font><font face="Courier New"><font color="#000000">)@&#8221;C:\&#8230;.\Macmillan.dot&#8221;; <br />newDoc.set_AttachedTemplate(</font><font color="#0000ff">ref </font></font><font face="Courier New"><font color="#000000">templateName); <br />wordApp.Visible = </font><font color="#0000ff">true</font><font color="#000000">; </font><br /></font>  
I was interested in finding out more about this error so I asked around internally and had it explained to me quite quickly. Looking into the type-library for Word and then the IL of the Interop Assembly would have likely provided the answer as well, but I&#8217;m glad I didn&#8217;t have to get into that. I&#8217;ll try to pass the explanation along without mangling it too much in the translation (feel free to correct me if you can, or add additional details). Some _properties_ of COM libraries are actually methods that support one or parameters, which is cool with VBA/VB6 as they supported this type of property as well, but they are translated (correctly it seems) by TlbImp.exe as methods (set\_AttachedTemplate, get\_AttachedTemplate)&#8230; VB.NET does some additional work for you so that you can still code against these property/methods as properties, but in C# you have to use them as methods. Interesting stuff, and likely a bit of a gotcha for people trying to move VBA code into .NET.

<div class="media">
  [Listening to: In the Air Tonight &#8211; <a href="http://www.windowsmedia.com/mg/search.asp?srch=Phil+Collins">Phil Collins</a> &#8211; Miami Vice (05:29)]
</div>